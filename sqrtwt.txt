= Square Root Algorithms =

== Binary Number Representation ==

The standard recursive binary square root algorithm accepts a binary number written in decimal notation.

We require that the number have the form: <code>x = [a0 a1 ... an . b0 b1 .. bm]</code>, where <code>x = a0 * 2^n + a1 * 2^n-1 + ... + an * 2^0 + b0 * 2^-1 + b1 * 2^-2 + ... + bm * 2^-m</code>.

We also require that the number of bits in front of the decimal point, <code>n</code>, and the number of bits after the decimal point, <code>m</code>, be even numbers.

If <code>x</code> can be written such that <code>n</code> or <code>m</code> is odd, we simply prepend or append a 0.

For example <code>x = 110.011 = 1*2^2 + 1*2^1 + 0*2^0 + 0*2^-1 + 1*2^-2 + 1*2^3</code>.

To use the standard algorithm, we need to prepend and append 0's and rewrite <code>x</code> as <code>0110.0110</code>.

We need the number of bits before and after the decimal point to be even because the standard algorithm recurses over <code>x</code> processing bits in pairs.

== The Rationale Behind the Standard Algorithm ==

Given a binary number, <code>x</code>, the standard algorithm recursively computes an approximation, <code>approx</code>, while trying to minimize the error between <code>x</code> and <code>approx^2</code> with each iteration.

Symbolically, the standard algorithm computes a value, approx, where <code>x - approx^2 = error</code>, and tries to minimize error with each iteration.

We recurse over <code>x</code>. At the beginning of each iteration, <code>n</code>, we draw the 2 most significant bits from <code>x</code> that we have not yet processed.

Let:

# <code>error (n)</code> denote the error during the n-th iteration
# <code>approx (n)</code> denote the approximation computed by the n-th iteration
# <code>a (n)</code> denotes the value of the n-th bit in <code>x</code>
# <code>x (n)</code> the portion of x iterated over so far.
# <code>b (n)</code> the bit computed for our approximation in the n-th iteration

In each iteration we extend our approximation by a single bit.

<pre>approx (0)     = 0
approx (n + 1) = 2 * approx (n) + b (n)</pre>
In each iteration we process two additional bits from x. If we let <code>x (n)</code> represent the bits processed so far, this means we shift the previous amount 2 bits and add the next 2 bits.

<pre>x (0) = 2 * a (0) + a (1)
x (n + 1) = 4 * x (n) + 2 * a (2 * n) + a (2 * n + 1)</pre>
Our error is simply:

<pre>error (n) = x (n) - approx (n)^2</pre>
From the requirement that the error is always positive, we can derive the equation that tells us whether or not the n-th bit in our approximation should be 1 or 0.

<pre>                                                        0 &lt;= error (n + 1)
                                                        0 &lt;= x (n + 1) - approx (n + 1)^2
                                         approx (n + 1)^2 &lt;= x (n + 1)
                                                      ... &lt;= 4 * x (n) + 2 * a (2 * n) + a (2 * n + 1)
                               (2 * approx (n) + b (n))^2 &lt;= ...
4 * approx (n)^2 + 2 * (2 * approx (n)) * b (n) + b (n)^2 &lt;= ...
                         4 * approx (n) * b (n) + b (n)^2 &lt;= (4 * x (n) - 4 * approx (n)^2) * 2 * a (2 * n) + a (2 * n + 1)
                                                      ... &lt;= 4 * error (n) * 2 * a (2 * n) + a (2 * n + 1)
                         b (n) * (4 * approx (n) + b (n)) &lt;= ...
                                       4 * approx (n) + 1 &lt;= 4 * error (n) * 2 * a (2 * n) + a (2 * n + 1)</pre>
because b (n) is either 1 or 0, we are only concerned with confirming that this condition is satisfied when b (n) is 1. This leads to:

what's more we can calculate the equation for error (n + 1) in terms of error (n)

<pre>error (0) = 2 * a (0) + a (1)
error (n + 1) = x (n + 1) - approx (n + 1)^2
          ... = 4 * x (n) + 2 * a (2 * n) + a (2 * n + 1) - (2 * approx (n) + b (n))^2
          ... = 4 * x (n) + ... - (4 * approx (n)^2 + 4 * approx (n) * b (n) + b (n)^2)
          ... = 4 * (x (n) - approx (n)^2) + ... - (4 * approx (n) * b (n) + b (n)^2)
error (n + 1) = (4 * error (n) + 2 * a (2 * n) + a (2 * n + 1)) - (b (n) * (4 * approx (n) + b (n)))</pre>
== The Standard Algorithm ==

Putting these equations together, we can derive the standard algorithm.

<pre>bsqrt_aux (n, m, x, err, approx)
  := if n = m
       then approx
       else block ([bn, approxn, errn],
         bn      : if 4 * decodeR (approx) + 1 &lt;=
                      4 * err + 2 * x [(2 * m) + 1] + x [(2 * m + 1) + 1]
                     then 1
                     else 0,
         approxn : encodeR (2 * decodeR (approx) + bn),
         errn    : (4 * err + 2 * x [(2 * m) + 1] + x [(2 * m + 1) + 1]) -
                   (bn * (4 * decodeR (approx) + bn)),
         bsqrt_aux (n, m + 1, x, errn, approxn));

bsqrt (x)
  := bsqrt_aux (length (x)/2, 0, x, 0, []);</pre>
