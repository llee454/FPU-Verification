/*
  Calculates a weak property for the maximum
  upper bound on the size of the registers used
  in Hauser's implementation of floating point
  division and square roots.

  given a binary number b, let [[b]] denote its
  maximum upper bound width.

  [[b0 + b1]]
    => 1 + max ([[b0]], [[b1]])

  [[2^n b]]
    => [[b]] + |n|
    note we assume that we do not lose precision. Accordingly, for negative n, we shift right by n bits and must have n bits to shift right by.

  [[b^2]]
    => 2 [[b]] - 1

  [[2^n b + k]] where [[k]] <= n
    => [[b]] + n
    because the new values in k are only added to the 0 bit suffix appended to b.

  [[b = k]] where k is a value
    => ceiling (log2 (k + 1))

  [[b - k]] where k is a value
    => [[b]]
    because we only care about maximum widths.

  [[b0 * b1]] where b0 is a single bit value 
    => [[b1]]

  using these equations we can derive a set of
  recurrence relations that describe the maximum
  upper bound for Hauser's register widths.

  note: sig represents the approximate and final result.
  bit represents the bitmask used to select which bit to write in sig (approx).
  c represents the value of the bit being written currently.
  c is a single bit value.

  [[a]] = s + 1
  [[b]] = s + 1

  sig (0) = 0
    => [[sig (0)]] = 1

  sig (n + 1) = sig (n) + c (n) * bit (n)
    => 1 + max ([[sig (n)]], [[bit (n)]])
    note: the most significant bit in sig (n) can never be 1. c (n) represents the value being written and bit (n) is all 0's except for the bit being written. hence we do not add 1.
    => max ([[sig (n)]], [[bit (n)]])

  rem (0) = a/2
    => [[2^-1 * a]]
    => [[a]] + 1
    => (s + 1) + 1
    => s + 2

  rem (n + 1) = 2 * rem (n) - c (n) * (2 * sig (n) + bit (n))
    => max ([[2 * rem (n)]],
            [[c (n) * (2 * sig (n) + bit (n))]]
    => max (1 + [[rem (n)]],
            [[2 * sig (n) + bit (n)]])
    note addition by bitmask is special because only one bit in bitmask equals 1 at any given time and except for the n = 0 this is not the most significant bit. This addition may never be able to produce a carry bit in the most significant bit (msb) position.
    => max (1 + [[rem (n)]],
            1 + max ([[2 * sig (n)]],
                     [[bit (n)]]))
    => max (1 + [[rem (n)]],
            max (1 + [[sig (n)]],
                 [[bit (n)]]))

  cycle (0) = s + 2
    => ceiling (log2 (s + 2 + 1))
    => ceiling (log2 (s + 3))

  cycle (n + 1) = cycle (n) - 1
    => [[cycle (n)]]

    note: cycle is a constant width. cycle (n) := ceiling (log2 (s + 3)).

  bit (0) = 2^s
    => ceiling (log2 (2^s + 1))
    => s + 1

  bit (n) = 2^(cycle (n) - 2)
    => ceiling (log2 (2^(cycle (n) - 2) + 1))
    => ceiling (log2 (2^((s + 2) - 2) + 1))
    => ceiling (log2 (2^s + 1))
    => s + 1

    note: bit is a constant width. because cycle (0) - 2 = s and all subsequent values of cycle (n) are smaller.
          bit (n) := s + 1

  summary (1) = a - 2^s
    => max ([[a]], [[2^s]])
    => max (s + 1, ceiling (log2 (2^s + 1)))
    => max (s + 1, s + 1)
    => s + 1

  summary (n + 1) = if _ then rem (n + 1) else summary (n)
    => max ([[rem (n + 1)]], [[summary (n)]])

  c (n) = 2 * sig (n) + bit (n) <= 2 * rem (n)
    => 1

  Given these equations, evaluate the width function for the various variables when n = 0 .. s + 1

  We can strengthen some of these equations.

  For example, the bit mask  
*/


log2 (n) := log (n)/log (2);

/*
  Accepts a numerical value and returns the
  number of bits needed to represent it.
*/
width_k (k) := ceiling (log2 (k + 1));

/*
  Represents the maximum number of bits needed
  to store the value in the Hauser's sqrt sig
  register.

  note: see the note above.
*/
width_sig (n)
  := if n = 0
       then width_k (0)
       else max (width_sig (n - 1), width_bit (n - 1));

/*
  Represents the maximum number of bits needed
  to store the value in the Hauser's sqrt rem
  register.
*/
width_rem (n)
  := if n = 0
       then s
       else max (1 + width_rem (n - 1),
                 max (1 + width_sig (n - 1)),
                      width_bit (n -1));

/*
  Represents the maximum number of bits needed
  to store the value in the Hauser's sqrt cycle
  register.
*/
width_cycle (n) := ceiling (log2 (s + 3));

/*
  Represents the maximum number of bits needed
  to store the value in the Hauser's sqrt bit
  register.
*/
width_bit (n) := s + 1;

/*
  Represents the maximum number of bits needed
  to store the value in the Hauser's sqrt summary
  register.
*/
width_summary (n)
  := if n = 1
       then s + 1
       else max (width_rem (n), width_summary (n - 1));

/*
  Represents the maximum number of bits needed
  to store the value in the Hauser's sqrt c
  register.
*/
width_c (n) := 1;
